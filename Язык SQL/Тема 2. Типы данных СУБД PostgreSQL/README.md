### Вводные сведения

- PostgreSQL имеет очень разнообразный набор встроенных типов
данных, т. е. тех типов, которые СУБД предоставляет в распоряжение
пользователя, как говорят, по умолчанию.
- Полная информация о типах данных в главе 8 документации:
https://postgrespro.ru/docs/postgresql/10/datatype
-  Пользователь имеет возможность создавать и свои собственные типы
данных, которые затем можно включить в систему и использовать их
так же, как и встроенные.
- Такая возможность адаптации системы типов данных к конкретным
ситуациям является одной из отличительных черт PostgreSQL.
  
# Числовые типы

### Классификация
- целочисленные типы
- числа фиксированной точности
- типы данных с плавающей точкой
- последовательные типы (serial)
***
### Целочисленные типы
- В составе целочисленных типов находятся следующие представители:
  ***smallint***, ***integer***, ***bigint***. Если атрибут таблицы имеет один из этих
типов, то он позволяет хранить только целочисленные данные.
- При этом перечисленные типы различаются по количеству байтов,
выделяемых для хранения данных.
- В PostgreSQL существуют псевдонимы для этих стандартизированных
имен типов, а именно: ***int2***, ***int4*** и ***int8***.
- Число байтов отражается в имени типа.
- При выборе конкретного целочисленного типа принимают во
внимание диапазон допустимых значений и затраты памяти.
- Зачастую тип integer считается оптимальным выбором с точки зрения
достижения компромисса между этими показателями
  
***
### Числа фиксированной точности (1)
- Представлены двумя типами — ***numeric*** и ***decimal***. Однако они являются
идентичными по своим возможностям. Поэтому мы будем проводить
изложение на примере типа numeric.
- Для задания значения этого типа используются два базовых понятия:
***масштаб (scale)**** и ***точность (precision)***.
- Масштаб показывает число значащих цифр, стоящих справа от десятичной
точки (запятой).
- Точность указывает общее число цифр как до десятичной точки, так и
после нее.
  
`12.3456`\
`12.3456` - точность\
`3456` - масштаб

- Например, у числа `12.3456` точность составляет 6 цифр, а масштаб — 4
цифры.
- Параметры этого типа данных указываются в скобках:
numeric( точность, масштаб ). Например, numeric( 6, 2 )
  
***
### Числа фиксированной точности (2)
- Главное достоинство — это обеспечение точных результатов при
выполнении вычислений, когда это, конечно, возможно в принципе.
Это оказывается возможным при выполнении сложения, вычитания и
умножения.
- Числа типа numeric могут хранить очень большое количество цифр:
`131072` цифры — до десятичной точки (запятой), `16383` — после точки.
- Однако нужно учитывать, что такая точность достигается за счет
замедления вычислений по сравнению с целочисленными типами и
типами с плавающей запятой. При этом для хранения числа
затрачивается больше памяти, чем в случае целых чисел.
  

- Данный тип следует выбирать для хранения денежных сумм, а также
в других случаях, когда требуется гарантировать точность вычислений.
  
***
### Типы данных с плавающей точкой (1)
- Представителями типов данных с плавающей точкой являются ***real*** и ***double precision***. Они представляют собой реализацию стандарта IEEE
«Standard 754 for Binary Floating-Point Arithmetic».
- Тип данных real может представить числа в диапазоне, как минимум,
от 1E-37 до 1E+37 с точностью не меньше 6 десятичных цифр.
- Тип double precision имеет диапазон значений примерно от 1E-307 до
1E+308 с точностью не меньше 15 десятичных цифр.
- При попытке записать в такой столбец слишком большое или
слишком маленькое значение будет генерироваться ошибка.
- Если точность вводимого числа выше допустимой, то будет иметь
место округление значения.
- А вот при вводе очень маленьких чисел, которые невозможно
представить значениями, отличными от нуля, будет генерироваться
ошибка потери значимости, или исчезновения значащих разрядов ***(an
  underflow error)***.

***
### Типы данных с плавающей точкой (2)
- При работе с числами таких типов нужно помнить, что сравнение двух чисел с плавающей точкой на предмет равенства их 
их значений может привести к неожиданному результам. Например:

```SQL
SELECT 0.1::real * 10  = 1.0::real;

?column?
----------
f
(1 строка)
```

- В дополнениик обычным числам эти типы данных поддерживают и специальные значения ***infinity*** (бесконечность),
***-infinity*** (отрицательная бесконечность) и ***NaN*** (не число).
- PostgreSQL поддерживает также тип данных ***float***, определенный в стандарте SQL. В объявлении типа может использоваться
параметр `float(p)`
- Если его значение лежит в диапазоне от 1 до 24, то это будет равносильно использованию типа real, а если же значение
лежит в диапазоне от 25 до 53, то это будет равносильно использованию типа double precision. Если же при объявлении типа
параметр не используется, то это также будет равносильно использованию типа double precision.

***
### Последовательные типы (serial) (1)
- Этот тип фактически реализован не как настоящий тип, а просто как удобная замена целой группы SQL-команд. Тип ***serial***
удобен в тех случаях, когда требуется в какой-либо столбец вставлять уникальные целые значения, например, значения
суррогантного первичного ключа. 

- Синтаксис для создания столбца типа ***serial*** таков:
```SQL
  CREATE TABLE tablename ( colname SERIAL ); 
```
Эта команда эквиалентна слудующей группе команд:
```SQL
  CREATE SEQUENCE tablename_colname_seq;
  CREATE TABLE tablename
  (
      colname integer NOT NULL DEFAULT nextval ( 'tablename_colname_seq' )
  );
  ALTER SEQUENCE tablename_colname_seq OWNED BY tablename.colname;
```
***
### Последовательные типы (serial) (2)
- Для пояснения вышеприведенных команд нам придется немного забежать вперед.
- Одним из видов объектов в базе данных являются так называемые ***последовательности***. Это, по сути, генераторы уникальных
целых чисел. Для работы с этими последовательностями-генераторами используются специальные функции. Одна из них - это 
функция ***nextval***, которая как раз и получает очередное число из последовательности, имя которой указано в качестве
параметра функции.
- В команде `CREATE TABLE` ключевое слово `DEFAULT` предписывает, чтобы СУБД, использовала в качестве значения
по умолчанию то значение, которое формирует функция ***nextval***. Поэтому если в команде  вставки строки в таблицу
`INSERT INTO` не будет передано значение для поля типа ***serial***, то СУБД обратится к услугам этой функции.

***
### Последовательные типы (serial) (3)
- В том случае, когда в таблице поле типа ***serial*** является суррогатным первичным ключем, тогда нет необходимости
указывать явное значение для вставки в это поле.
- Кроме типа ***serial*** существуют еще два аналогичных типа: ***bigserial*** и ***smallserial***. Им фактически, 
за кадром, соответствуют типы ***bigint*** и ***smallint***.

> Практический совет. При выборе конкретной последовательного типа нужно учитывать 
> предпологаемое число строк в таблице и частоту удаления и вставки строк, поскольку 
> даже для небольшой таблицы может потребоваться большой диапазон, если операции удаления и вставки строк выполняются
> часто.

***
# Символьные (строковые) типы
### Стандартные представители строковых типов
- Стандартные представители строковых типов - **character**, **varying(n)** и **character(n)**, где параметр указывает
максимальное число символов в строке, которую можно сохранить в столбце такого типа.
- При работе с многобайтовыми кодировками символов, например, `UTF-8`, нужно учитывать, что речь идет именно о _символах_,
а не о байтах.
- Если сохраняемая строка символов будет короче, чем указано в определении типа, то значение типа **character** будет
дополнено проблемами до требуемой длины, а значение типа **character** **varying** будет сохранено так, как есть.
- Типа **character** **varying(n)** и **character(n)** имеют псевдонимы **varchar(n)** и **char(n)** соответственно. На практике, как правило
используют именно эти краткие псевдонимы.

***
### Тип next - расширение PostgreSQL

- PostgreSQL дополнительно предлагает еще один символьный тип - ***text***. В столбец этого типа можно ввести 
сколь угодное большое значение, конечно, в пределах, установленных при компиляции исходных текстов СУБД.

> Практичеий совет. Документация рекомендует использовать типы **text** и **varchar**, поскольку такое отличительное
> свойство типа character, как дополнение значений пробелами, на практике почти не востребовано. В PostgreSQL обычно
> используется тип **text**.

- Константы символьных типов в SQL-командах заключаются в одинарные ковычки:
```SQL
SELECT 'PostgreSQL';

?column?
----------
PostgreSQL
(1 строка)
```

***
### Что делать с кавычками в константах?

- В том случае, когда в константе содержится символ одинарной кавычки или обратной косой черты, их необходимо удваивать.
Например:
```SQL
SELECT 'PGDAY''17';

?column?
---------
PGDAY'17
(1 строка)
```
- Можно использовать символы "$" в качестве ограничителя. Это расширение, предлагаемое PostgreSQL. При этом уже не нужно
удваивать никакие символы, содержащиеся в самой константе: ни одинарные кавычки, ни символы обратной косой черты. Например:
```SQL
SELECT $$PGDAY'17$$;

?column?
---------
PGDAY'17
(1 строка)
```
***
### Строковые константы  стиле языка С
- PostgreSQL предлагает еще одно расширение стандарта SQL. Например, для включения в константу символа новой строки "\n"
нужно сделать так:
```SQL
SELECT E'PПDAY\n17';
?column?
---------
PGDAY   +
17
(1 строка)
```